Jordan contributed to the code to smartly collect data from sensors, code to facilitate communication between Arduino boards, and logic to implement the ultrasonic sensor mode.

As a performance optimization, caching was implemented for sensors so that each sensor would be queried at most once during a single AI decision-making cycle. This optimization allowed the AI to ask for the sensor data as many times as it wanted, and the function supplying that information would either serve the cached value, or query the sensor if it didn't have a fresh cached value. This introduced the additional overhead of clearing the cache at the beginning of AI decisions, but this prepares the code for change and protects against unnecessarily querying the sensors.

The caching functionality was implemented quite simply, with a boolean value to indicate if a value had been cached and a numerical value to hold the last measured value. When a value is requested, the cache is checked, and if the value is fresh, the cached value is returned. This architecture puts the burden of cache expiration on the user, which is an acceptable trade-off in this situation, because there is an obvious place to expire the cache: at the beginning of the AI::decide() function that makes the decision as to what the next action the robot should take is.

A special case of caching is the temperature sensor, which was offloaded to a second Arduino due to a lack of analog pins. The Arduino Uno board that was used has 6 analog pins, 4 of which were used for gathering reflectivity data, and two of which were used for inter-Arduino communication. The temperature sensor was offloaded to a slave Arduino, and the function to read temperature was reconfigured to request a value from the slave instead of read directly from a sensor. This presented a special case because the latency on receiving those measurements is much higher than for a local sensor, so the cache was configured to treat a value as fresh for two seconds before querying the slave Arduino again. This timeout was selected because it would not introduce appreciable performance overhead, and because the ambient temperature is unlikely to change appreciably in two seconds.

The inter-Arduino communications were implemented with the Arduino's built-in Wire library. This library allowed for daisy-chaining Arduinos, as was done in the robot, and addressing, to allow for unique identification of slave Arduinos. In the robot, the slaves were assigned unique addresses 8 and 9 for the Nano and slave Uno, respectively, and queried accordingly.

To communicate decision-making events on the master Arduino to the slave Arduinos, a function was created. This function simply began transmissions to both slave boards, sent the specified command (in the form of a single byte), and then exited. The slave boards would in turn receive the commands and actuate accordingly, either playing a sound, or displaying a message on the LCD. The commands were specified beforehand in a lookup table, so that the master and slave could communicate effectively.

In the final design, two seperate power supplies were employed, one for the master and one for the slaves, which shared a power supply. This change was made to isolate the two from one another, because the motors driven by the master draw a signifigant amount of power, and this draw was affecting the slaves. This configuration was only used in the final design, with power for testing coming from a host computer.

The most promiment issue encountered was with inter-Arduino communication. The protocol employed by the Wire library relies on each board sharing a common ground and 5V, and orchestrating that connection was difficult, especially when the master was powering both slaves. The problem was isolated to being that some 5V pins worked better for receiving power than others, but the reason behind this was not ascertained. It was not an issue when two power supplies were used, as long as the grounds were connected.